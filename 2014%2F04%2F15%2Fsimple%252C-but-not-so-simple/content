<p>In spite of a Scheme implementation, Guile is also an extension language platform.
This means you can write new language on it, which could be totally different from Scheme.
Say, PHP/Lua/Ecmascript...and all these front-end will take advantage of the compiling optimization
machenism of Guile.</p>
<p>This article introduced a simple way to define a very simple programing language in 50 lines, in Guile.</p>
<i>The contents may require some basic knowledge of compiler principle. If you're not so comfortable with the
terms in the article, please read the Dragon Book[0] first.</i>  

<h4>Some concepts</h4>
<p>It's better to clarify something before we start. When I'm talking <font color='red'>'create a language'</font>, I mean designing
the grammar of the language in certain form, usually, in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a>.
And when I say <font color='red'>'implement a language'</font>, it means writing lexer/parser, then transfer the source code to 
an immediate form, like AST(Abstract Syntax Tree) or other IL(<a href="https://en.wikipedia.org/wiki/Intermediate_language">Intermediate Language</a>) for some optimizations. Finally we may have two choices:</p>
<p>1. To interprete the IR to get the meaningful result -- It's an Interpreter!</p>
<p>2. To generate some kind of code to store in a file -- It's a Compiler, if the final code is bytecode,
you're writing a VM one; or native code for AOT compiler.</p>
<p>This article is about the front-end only: lexer and parser, and transforming a simple AST (actually it's list type in Scheme)
to another kind of AST, tree-il,
the first level of Guile intermediate language. After the tree-il was generated, the rest of the compiling work would be taken by Guile.<p>
<p>So we don't have to face the complicated compiling optimization stuffs. This feature makes Guile very easy to implement new languages.
Well, now we need to create a language first, we name it 'simple', here's the BNF:</p>