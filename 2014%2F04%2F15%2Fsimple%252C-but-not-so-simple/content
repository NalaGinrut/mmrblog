<p>In spite of a Scheme implementation, Guile is also an extension language platform.
This means you can write new language on it, which could be totally different from Scheme.
Say, PHP/Lua/Ecmascript...and all these front-end will take advantage of the compiling optimization
machenism of Guile.</p>
<p>This article introduced a simple way to define a very simple programing language with <font color='blue'>50 lines</font> code, in Guile.</p>
<i>The contents may require some basic knowledge of compiler principle. If you're not so comfortable with the
terms in the article, please read the Dragon Book[0] first.</i>  

<h3>Some concepts</h3>
<p>It's better to clarify something before we start. When I'm talking <font color='red'>'create a language'</font>, I mean designing
the grammar of the language in certain form, usually, in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a>.
And when I say <font color='red'>'implement a language'</font>, it means writing lexer/parser, then transfer the source code to 
an immediate form, like AST(Abstract Syntax Tree) or other IL(<a href="https://en.wikipedia.org/wiki/Intermediate_language">Intermediate Language</a>) for some optimizations. Finally we may have two choices:</p>
<p>1. To interprete the IR to get the meaningful result -- It's an Interpreter!</p>
<p>2. To generate some kind of code to store in a file -- It's a Compiler, if the final code is bytecode,
you're writing a VM one; or native code for AOT compiler.</p>
<p>This article is about the front-end only: lexer and parser, and transforming a simple AST (actually it's list type in Scheme)
to another kind of AST, tree-il,
the first level of Guile intermediate language. After the tree-il was generated, the rest of the compiling work would be taken by Guile.</p>
<p>So we don't have to face the complicated compiling optimization stuffs. This feature makes Guile very easy to implement new languages.
Well, now we need to create a language first, we name it 'simple', here's the BNF:</p>
<h3>The language:</h3>

<pre class="sh_guile">
exp ::= exp op exp
      | number

op  ::= * 
      | /  ;; `multi' and `div' has higher precedence than `plus' and `minus'
      | +
      | -
</pre>
<p>Very easy huh? Only the elementary arithmetic. The only difficulty is to handle the precedence, we can rewrite it to this:</p>

<pre class="sh_guile">
exp ::= exp + term
      | exp - term
      | term

term ::= term * factor
       | term / factor
       | factor
</pre>
<p>This new BNF is clearer than the old one, and it promises the correct precedence.[0]</p>

<h3>LALR parser generator:</h3>

<p>Guile has intergrated LALR(1) parser generator in the core, but no lexer generator, so users have to write lexer manually.
It's fine to me, since writing lexer is interesting. Then the key point to multi-lang is to know what does
this lalr module wants to eat.</p>
<p>Anyway there's an alternative external lexer generator: <a href="http://www.call-with-current-continuation.org/eggs/silex.ps">silex</a>.</p>

<p>
The parser generated by the lalr-parser macro is a function that takes two parameters.
The first parameter is a lexical analyzer while the second is an error handler.
A token is either a symbol, or a record created by the function make-lexical-token:
</p>
<pre class="sh_guile">
(make-lexical-token category source value)
</pre>

<p>A lexical token record has three fields: category, which must be a symbol, a source location object source,
and a semantic value associated with the token. For example, a string token would have a category set to
'STRING while its semantic value is set to the string value "hello".
The field accessors are:</p>

<pre class="sh_guile">
lexical-token-category
lexical-token-source
lexical-token-value
</pre>
<p>Once the end of file encountered, the lexical analyzer must always return the symbol <font color='green'>'*eoi*</font>.
In spite of this, your lexer must return the token struct to the parser, then let the parser do its work.</p>

<p>Before we start our 50-lines tour, we need some preparation, the code below is to load LALR module, and define two helper functions.</p>
<pre class="sh_guile">
;; Be sure you imported LALR module:
(use-modules (system base lalr))

;; Two helper macros to create the token struct for returning
(define-syntax-rule (port-source-location port)
  (make-source-location (port-filename port)
                        (port-line port)
                        (port-column port)
                        (false-if-exception (ftell port))
                        #f))
(define-syntax-rule (return port category value)
  (make-lexical-token category (port-source-location port) value))
</pre>

<h3>The lexer:</h3>
<p>The lexer is a tool of lexical analysis, which aims to produce <a href="https://en.wikipedia.org/wiki/Token_(parser)#Token">tokens</a>.</p>
<p>Let's see some code:</p>

<p>These functions are useful to predicate different token for you.</p>
<pre class="sh_guile">
(define (is-whitespace? c) (char-set-contains? char-set:whitespace c))
(define (is-number? c) (char-set-contains? char-set:hex-digit c))
;; operators, in this simple case, we just have four operators
(define (is-op? c) (string-contains "+-*/" (string c)))
(define (is-delimiter? c) 
  (or (eof-object? c) (string-contains " +-*/;\n" (string c))))
</pre>

<p>And these two functions are used to get the basic two types of token in our Simple language: numbers, and the operators.</p>
<pre class="sh_guile">
(define (get-number port)
 (let lp((c (peek-char port)) (ret '()))
   (cond
    ((is-delimiter? c) ; encounter delimiter, finish to read a number
     ;; convert to a number representation
     (string->number (list->string (reverse ret))))
    (else
     (read-char port) ; next char
     (lp (peek-char port) (cons c ret))))))
(define (get-op port) (string->symbol (string (read-char port))))
</pre>

<p>The key function is <font color='red'>next-token</font> which is used to <font color='blue'>check</font>
then <font color='blue'>get</font> then <font color='blue'>return</font> the proper token to the parser.</p>
<pre class="sh_guile">
(define (next-token port)
  (let ((c (peek-char port)))
    (cond
     ((or (eof-object? c) (char=? c #\nl)) ; end of line, or end src
      '*eoi*) ; return '*eoi* because LALR module need it
     ((is-whitespace? c)
      (read-char port)
      (next-token port)) ; skip white space
     ((is-number? c)
      (return port 'number (get-number port)))
     ((is-op? c)
      (return port (get-op port) #f))
     (else
      (read-char port)
      (next-token port)))))
</pre>
<p>This tokenizer is important because the parser need it be passed in.</p> 
<pre class="sh_guile">
(define (make-simple-tokenizer port) (lambda () (next-token port)))
</pre>
<p>The tokenizer must return a thunk (stands for a function without any args)
Each time calling this thunk, it returns a token. The parser will call it
several times automatically, depends on the length of your source code.
That's what LALR parser need to be fed.</p>

<h3>The parser</h3>
<p>Now it's the parser part:</p>
<pre class="sh_guile">
(define (make-parser)
  (lalr-parser
   (number (left: + -) (left: * /))
   (program (exp) : $1
            (*eoi*) : (call-with-input-string "" read)) ; *eof-object*
   (exp  (exp + term) : `(+ ,$1 ,$3)
         (exp - term) : `(- ,$1 ,$3)
         (term) : $1)
   (term (term * factor) : `(* ,$1 ,$3)
         (term / factor) : `(/ ,$1 ,$3)
         (factor) : $1)
   (factor (number) : `(number ,$1))))
</pre>
<p>You may found that we just converted the BNF to a special simple AST, which is actually the
list in Scheme, say:</p>
<pre class='sh_guile'>
'(* (number 1) (number 3))
</pre>
<p>This is one of the perfect features of Scheme, because you can use this fundamental data type
to indicate an AST. You don't have to write any new/complex data structure for that.
That's why I emphasized that it is very cool to implement new languages with Scheme language.</p>
<p>Then you may try this line in the REPL to test if the precedence is correct:</p>
<pre class="sh_guile">
(call-with-input-string "1+1*2/3-4" 
  (lambda (port) 
    ((make-parser) (make-simple-tokenize port) read-simple)))
</pre>
It should return:
<pre class="sh_guile">
(- (+ (number 1) 
      (/ (* (number 1) (number 2))
         (number 3)))
   (number 4))
</pre>
Maybe you're not so comfortable with this form, it's actually the same with:
<pre class="sh_c">
(1 + ((1 * 2) / 3)) - 4
</pre>
<p>It's the correct precedence according to our BNF.</p>

<h3>Tree IL</h3>
<p>These code defined a function named <font color='red'>compile-tree-il</font> which is used
to transform our simple AST to Tree-IL [1]. You see, only few lines.</p>
<pre class="sh_guile">
(define (compile-tree-il exp env opts)
  (values (parse-tree-il (comp exp '())) env env))
(define (comp src e)
  (match src
    (('number x) `(const ,x))
    ;; If you're using master branch of Guile, please use `call' to replace `apply'.
    ;; If you are using stable-2.0 or Guile-2.0.x, `apply' should be fine [1].
    ((op x y) `(apply (primitive ,op) ,(comp x e) ,(comp y e)))))
</pre>



<p>You may put all the code showed above into one file, say, <font color='red'>simple.scm</font>. 
And make sure it's in language/simple directory, please make sure for it. Because Guile will pick
the language front-end from language directory when you ask for loading the language.</p>

<h3>Final step, the spec!</h3>
<p>Although we've done all the coding work for our Simple language, we have to write one more file to let
Guile know it. This is the spec file. The syntax is very easy:</p>
<pre class="sh_guile">
(define-module (language simple spec)
  #:use-module (system base language)
  #:use-module (language simple simple)
  #:export (simple))

;; The definition of Simple language
;; You don't have to understand it, just copy and modify it from other front-end
(define-language simple
  #:title       "simple"
  #:reader      (lambda (port env) 
                  ((make-parser) (make-simple-tokenizer port) error))
  #:compilers   `((tree-il . ,compile-tree-il))
  #:printer     write)
</pre>

<h3>Run it!</h3>
<p>You may type all the code yourself, it's better. But here is a git repo if you need any example:</p>
<pre class="sh_sh">
git clone https://github.com/NalaGinrut/simple.git
</pre>
<p>Please type <font color='red'>sudo make install</font>, and run Guile REPL (just run 'guile' in your command line).
And run <font color='red'>,L simple</font> in your REPL, you should see:</p>
<pre class="sh_sh">
GNU Guile 2.1.0.1771-48c2a
Copyright (C) 1995-2014 Free Software Foundation, Inc.

Guile comes with ABSOLUTELY NO WARRANTY; for details type `,show w'.
This program is free software, and you are welcome to redistribute it
under certain conditions; type `,show c' for details.

Enter `,help' for help.
scheme@(guile-user)> ,L simple
;;; note: auto-compilation is enabled, set GUILE_AUTO_COMPILE=0
;;;       or pass the --no-auto-compile argument to disable.
;;; compiling /usr/local/share/guile/2.2/language/simple/spec.scm
;;; compiled /home/nalaginrut/.cache/guile/ccache/2.2-LE-8-3.4/usr/local/share/guile/2.2/language/simple/spec.scm.go
Happy hacking with simple!  To switch back, type `,L scheme'.
simple@(guile-user)> 
</pre>
<p>OK, now you see the language was changed to 'simple', and just play maths in it:</p>
<pre class="sh_c">
1+1
=> 2
3*4
=> 12
</pre>

<h3>Any further?</h3>
<p>'simple' is just a simple language, maybe too simple for a serious compiler writer. Because even a front-end will
take you a lot of time and hack power. No mention the backend. Fortunately, Guile provides a nice way to let language
fans focus on the grammar rather than optimization. Nevertheless, all the languages front-end can call from each other,
If you're interested in this feature, please read Wingo's post[2].</p>
<p>I wrote an IMP[3] language before. I expect to share more in the future.</p>  

<p><b>----------</b></p>
<p><b>Refs</b></p>
<p>[0] http://www.amazon.com/Compilers-Principles-Techniques-Tools-Edition/dp/0321486811</p>
<p>[1] Tree-IL in Guile: https://www.gnu.org/software/guile/manual/html_node/Tree_002dIL.html</p>
<p>[2] Andy Wingo introduced Ecmacript in Guile, and inter calling between Ecmascript and Scheme:
http://wingolog.org/archives/2009/02/22/ecmascript-for-guile</p>
<p>[3] https://github.com/NalaGinrut/imp </p>
