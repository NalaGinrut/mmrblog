<p>In spite of a Scheme implementation, Guile is also an extension language platform.
This means you can write new language on it, which could be totally different from Scheme.
Say, PHP/Lua/Ecmascript...and all these front-end will take advantage of the compiling optimization
machenism of Guile.</p>
<p>This article introduced a simple way to define a very simple programing language in 50 lines, in Guile.</p>
<i>The contents may require some basic knowledge of compiler principle. If you're not so comfortable with the
terms in the article, please read the Dragon Book[0] first.</i>  

<h4>Some concepts</h4>
<p>It's better to clarify something before we start. When I'm talking <font color='red'>'create a language'</font>, I mean designing
the grammar of the language in certain form, usually, in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a>.
And when I say <font color='red'>'implement a language'</font>, it means writing lexer/parser, then transfer the source code to 
an immediate form, like AST(Abstract Syntax Tree) or other IL(<a href="https://en.wikipedia.org/wiki/Intermediate_language">Intermediate Language</a>) for some optimizations. Finally we may have two choices:</p>
<p>1. To interprete the IR to get the meaningful result -- It's an Interpreter!</p>
<p>2. To generate some kind of code to store in a file -- It's a Compiler, if the final code is bytecode,
you're writing a VM one; or native code for AOT compiler.</p>
<p>This article is about the front-end only: lexer and parser, and transforming a simple AST (actually it's list type in Scheme)
to another kind of AST, tree-il,
the first level of Guile intermediate language. After the tree-il was generated, the rest of the compiling work would be taken by Guile.</p>
<p>So we don't have to face the complicated compiling optimization stuffs. This feature makes Guile very easy to implement new languages.
Well, now we need to create a language first, we name it 'simple', here's the BNF:</p>
<h4>The language:</h4>

<pre class="sh_guile">
exp ::= exp op exp
      | number

op  ::= * 
      | /  ;; `multi' and `div' has higher precedence than `plus' and `minus'
      | +
      | -
</pre>
<p>Very easy huh? Only the elementary arithmetic. The only difficulty is to handle the precedence, we can rewrite it to this:</p>

<pre class="sh_guile">
exp ::= exp + term
      | exp - term
      | term

term ::= term * factor
       | term / factor
       | factor
</pre>
<p>This new BNF is clearer than the old one, and it promises the correct precedence.[0]</p>

<h4>LALR parser generator:</h4>

<p>Guile has intergrated LALR(1) parser generator in the core, but no lexer generator, so users have to write lexer manually.
It's fine to me, since writing lexer is interesting. Then the key point to multi-lang is to know what does
this lalr module wants to eat.</p>
<p>Anyway there's an alternative external lexer generator: <a href="http://www.call-with-current-continuation.org/eggs/silex.ps">silex</a>.</p>

<p>
The parser generated by the lalr-parser macro is a function that takes two parameters.
The first parameter is a lexical analyzer while the second is an error handler.
A token is either a symbol, or a record created by the function make-lexical-token:
</p>
<pre class="sh_guile">
(make-lexical-token category source value)
</pre>

<p>A lexical token record has three fields: category, which must be a symbol, a source location object source,
and a semantic value associated with the token. For example, a string token would have a category set to
'STRING while its semantic value is set to the string value "hello".
The field accessors are:</p>

<pre class="sh_guile">
lexical-token-category
lexical-token-source
lexical-token-value
</pre>
<p>Once the end of file encountered, the lexical analyzer must always return the symbol <font color='green'>'*eoi*</font>.
In spite of this, your lexer must return the token struct to the parser, then let the parser do its work.</p>

<p>Before we start our 50-lines tour, we need some preparation, the code below is to load LALR module, and define two helper functions.</p>
<pre class="sh_guile">
;; Be sure you imported LALR module:
(use-modules (system base lalr))

;; Two helper macros to create the token struct for returning
(define-syntax-rule (port-source-location port)
  (make-source-location (port-filename port)
                        (port-line port)
                        (port-column port)
                        (false-if-exception (ftell port))
                        #f))
(define-syntax-rule (return port category value)
  (make-lexical-token category (port-source-location port) value))
</pre>

<h4>The lexer:</h4>
<p>The lexer is a tool of lexical analysis, which aims to produce <a href="https://en.wikipedia.org/wiki/Token_(parser)#Token">tokens</a>.</p>
<p>Let's see some code:</p>

<p>These functions are useful to predicate different token for you.</p>
<pre class="sh_guile">
(define (is-whitespace? c) (char-set-contains? char-set:whitespace c))
(define (is-number? c) (char-set-contains? char-set:hex-digit c))
;; operators, in this simple case, we just have four operators
(define (is-op? c) (string-contains "+-*/" (string c)))
(define (is-delimiter? c) 
  (or (eof-object? c) (string-contains " +-*/;\n" (string c))))
</pre>

<p>And these two functions are used to get the basic two types of token in our Simple language: numbers, and the operators.</p>
<pre class="sh_guile">
(define (get-number port)
 (let lp((c (peek-char port)) (ret '()))
   (cond
    ((is-delimiter? c) ; encounter delimiter, finish to read a number
     ;; convert to a number representation
     (string->number (list->string (reverse ret))))
    (else
     (read-char port) ; next char
     (lp (peek-char port) (cons c ret))))))
(define (get-op port) (string->symbol (string (read-char port))))
</pre>